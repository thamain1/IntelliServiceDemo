/*
  # Fix Function Search Paths (with CASCADE)

  Drop problematic functions with CASCADE and recreate with search paths.
*/

DROP FUNCTION IF EXISTS public.get_current_user_role() CASCADE;
DROP FUNCTION IF EXISTS public.generate_prj_ticket_number(uuid);
DROP FUNCTION IF EXISTS public.get_next_ticket_number(text, uuid);
DROP FUNCTION IF EXISTS public.calculate_estimate_totals(uuid);
DROP FUNCTION IF EXISTS public.get_current_labor_rate_tier(date);
DROP FUNCTION IF EXISTS public.get_global_billing_rate(text);

CREATE OR REPLACE FUNCTION public.generate_invoice_number() RETURNS text LANGUAGE plpgsql SECURITY DEFINER SET search_path = public, pg_temp AS $$ DECLARE next_num integer; BEGIN SELECT COALESCE(MAX(CAST(SUBSTRING(invoice_number FROM '[0-9]+') AS integer)), 0) + 1 INTO next_num FROM public.invoices; RETURN 'INV-' || LPAD(next_num::text, 6, '0'); END; $$;
CREATE OR REPLACE FUNCTION public.update_accounting_settings_timestamp() RETURNS trigger LANGUAGE plpgsql SECURITY DEFINER SET search_path = public, pg_temp AS $$ BEGIN NEW.updated_at = now(); RETURN NEW; END; $$;
CREATE OR REPLACE FUNCTION public.get_accounting_setting(setting_key text) RETURNS text LANGUAGE plpgsql SECURITY DEFINER SET search_path = public, pg_temp AS $$ DECLARE setting_value text; BEGIN SELECT value INTO setting_value FROM public.accounting_settings WHERE key = setting_key; RETURN setting_value; END; $$;
CREATE OR REPLACE FUNCTION public.get_accounting_setting_numeric(setting_key text) RETURNS numeric LANGUAGE plpgsql SECURITY DEFINER SET search_path = public, pg_temp AS $$ DECLARE setting_value numeric; BEGIN SELECT value::numeric INTO setting_value FROM public.accounting_settings WHERE key = setting_key; RETURN COALESCE(setting_value, 0); END; $$;
CREATE OR REPLACE FUNCTION public.create_invoice_from_ticket() RETURNS trigger LANGUAGE plpgsql SECURITY DEFINER SET search_path = public, pg_temp AS $$ DECLARE invoice_id uuid; labor_rate numeric; tax_rate numeric; subtotal numeric := 0; tax_amount numeric := 0; total_amount numeric := 0; BEGIN IF NEW.status = 'completed' AND OLD.status != 'completed' THEN labor_rate := public.get_accounting_setting_numeric('default_labor_rate'); tax_rate := public.get_accounting_setting_numeric('default_tax_rate'); subtotal := COALESCE(NEW.hours_onsite, 0) * labor_rate; tax_amount := subtotal * (tax_rate / 100); total_amount := subtotal + tax_amount; INSERT INTO public.invoices (invoice_number, customer_id, ticket_id, issue_date, due_date, status, subtotal, tax_amount, total_amount, created_by) VALUES (public.generate_invoice_number(), NEW.customer_id, NEW.id, CURRENT_DATE, CURRENT_DATE + INTERVAL '30 days', 'draft', subtotal, tax_amount, total_amount, NEW.assigned_to) RETURNING id INTO invoice_id; NEW.invoice_id := invoice_id; END IF; RETURN NEW; END; $$;
CREATE OR REPLACE FUNCTION public.calculate_rounded_hours(hours_decimal numeric) RETURNS numeric LANGUAGE plpgsql IMMUTABLE SET search_path = public, pg_temp AS $$ BEGIN RETURN CEIL(hours_decimal * 60 / 15) * 15 / 60.0; END; $$;
CREATE OR REPLACE FUNCTION public.generate_project_number() RETURNS text LANGUAGE plpgsql SECURITY DEFINER SET search_path = public, pg_temp AS $$ DECLARE next_num integer; BEGIN SELECT COALESCE(MAX(CAST(SUBSTRING(project_number FROM '[0-9]+') AS integer)), 0) + 1 INTO next_num FROM public.projects; RETURN 'PRJ-' || LPAD(next_num::text, 6, '0'); END; $$;
CREATE OR REPLACE FUNCTION public.get_project_number() RETURNS text LANGUAGE plpgsql SECURITY DEFINER SET search_path = public, pg_temp AS $$ BEGIN RETURN public.generate_project_number(); END; $$;
CREATE FUNCTION public.generate_prj_ticket_number(proj_id uuid) RETURNS text LANGUAGE plpgsql SECURITY DEFINER SET search_path = public, pg_temp AS $$ DECLARE next_num integer; proj_num text; BEGIN SELECT project_number INTO proj_num FROM public.projects WHERE id = proj_id; SELECT COALESCE(next_number, 1) INTO next_num FROM public.ticket_sequences WHERE project_id = proj_id FOR UPDATE; IF NOT FOUND THEN INSERT INTO public.ticket_sequences (project_id, next_number) VALUES (proj_id, 2) RETURNING 1 INTO next_num; ELSE UPDATE public.ticket_sequences SET next_number = next_number + 1 WHERE project_id = proj_id; END IF; RETURN proj_num || '-' || LPAD(next_num::text, 3, '0'); END; $$;
CREATE OR REPLACE FUNCTION public.generate_svc_ticket_number() RETURNS text LANGUAGE plpgsql SECURITY DEFINER SET search_path = public, pg_temp AS $$ DECLARE next_num integer; BEGIN SELECT COALESCE(next_number, 1) INTO next_num FROM public.ticket_sequences WHERE project_id IS NULL FOR UPDATE; IF NOT FOUND THEN INSERT INTO public.ticket_sequences (project_id, next_number) VALUES (NULL, 2) RETURNING 1 INTO next_num; ELSE UPDATE public.ticket_sequences SET next_number = next_number + 1 WHERE project_id IS NULL; END IF; RETURN 'SVC-' || LPAD(next_num::text, 6, '0'); END; $$;
CREATE FUNCTION public.get_next_ticket_number(ticket_type text, proj_id uuid DEFAULT NULL) RETURNS text LANGUAGE plpgsql SECURITY DEFINER SET search_path = public, pg_temp AS $$ BEGIN IF ticket_type = 'project' AND proj_id IS NOT NULL THEN RETURN public.generate_prj_ticket_number(proj_id); ELSE RETURN public.generate_svc_ticket_number(); END IF; END; $$;
CREATE OR REPLACE FUNCTION public.auto_generate_ticket_number() RETURNS trigger LANGUAGE plpgsql SECURITY DEFINER SET search_path = public, pg_temp AS $$ BEGIN IF NEW.ticket_number IS NULL OR NEW.ticket_number = '' THEN NEW.ticket_number := public.get_next_ticket_number(NEW.ticket_type, NEW.project_id); END IF; RETURN NEW; END; $$;
CREATE OR REPLACE FUNCTION public.generate_estimate_number() RETURNS text LANGUAGE plpgsql SECURITY DEFINER SET search_path = public, pg_temp AS $$ DECLARE next_num integer; BEGIN SELECT COALESCE(next_number, 1) INTO next_num FROM public.estimate_sequences WHERE id = 1 FOR UPDATE; IF NOT FOUND THEN INSERT INTO public.estimate_sequences (id, next_number) VALUES (1, 2) RETURNING 1 INTO next_num; ELSE UPDATE public.estimate_sequences SET next_number = next_number + 1 WHERE id = 1; END IF; RETURN 'EST-' || LPAD(next_num::text, 6, '0'); END; $$;
CREATE FUNCTION public.calculate_estimate_totals(est_id uuid) RETURNS void LANGUAGE plpgsql SECURITY DEFINER SET search_path = public, pg_temp AS $$ DECLARE line_subtotal numeric; est_tax_rate numeric; tax_amt numeric; total_amt numeric; BEGIN SELECT COALESCE(SUM(line_total), 0) INTO line_subtotal FROM public.estimate_line_items WHERE estimate_id = est_id; SELECT tax_rate INTO est_tax_rate FROM public.estimates WHERE id = est_id; tax_amt := line_subtotal * (COALESCE(est_tax_rate, 0) / 100); total_amt := line_subtotal + tax_amt; UPDATE public.estimates SET subtotal = line_subtotal, tax_amount = tax_amt, total_amount = total_amt, updated_at = now() WHERE id = est_id; END; $$;
CREATE OR REPLACE FUNCTION public.auto_generate_estimate_number() RETURNS trigger LANGUAGE plpgsql SECURITY DEFINER SET search_path = public, pg_temp AS $$ BEGIN IF NEW.estimate_number IS NULL OR NEW.estimate_number = '' THEN NEW.estimate_number := public.generate_estimate_number(); END IF; RETURN NEW; END; $$;
CREATE OR REPLACE FUNCTION public.trigger_update_estimate_totals() RETURNS trigger LANGUAGE plpgsql SECURITY DEFINER SET search_path = public, pg_temp AS $$ BEGIN IF TG_OP = 'DELETE' THEN PERFORM public.calculate_estimate_totals(OLD.estimate_id); RETURN OLD; ELSE PERFORM public.calculate_estimate_totals(NEW.estimate_id); RETURN NEW; END IF; END; $$;
CREATE OR REPLACE FUNCTION public.trigger_log_estimate_status_change() RETURNS trigger LANGUAGE plpgsql SECURITY DEFINER SET search_path = public, pg_temp AS $$ BEGIN IF OLD.status IS DISTINCT FROM NEW.status THEN INSERT INTO public.estimate_activity_log (estimate_id, action_type, description, performed_by) VALUES (NEW.id, 'status_change', 'Status changed from ' || OLD.status || ' to ' || NEW.status, NEW.updated_by); END IF; RETURN NEW; END; $$;
CREATE OR REPLACE FUNCTION public.set_default_expiration_date() RETURNS trigger LANGUAGE plpgsql SECURITY DEFINER SET search_path = public, pg_temp AS $$ BEGIN IF NEW.expiration_date IS NULL THEN NEW.expiration_date := CURRENT_DATE + INTERVAL '30 days'; END IF; RETURN NEW; END; $$;
CREATE FUNCTION public.get_current_labor_rate_tier(work_date date DEFAULT CURRENT_DATE) RETURNS text LANGUAGE plpgsql SECURITY DEFINER SET search_path = public, pg_temp AS $$ DECLARE rate_tier text; BEGIN SELECT tier_name INTO rate_tier FROM public.labor_rate_profile WHERE is_active = true AND effective_date <= work_date ORDER BY effective_date DESC LIMIT 1; RETURN COALESCE(rate_tier, 'standard'); END; $$;
CREATE FUNCTION public.get_global_billing_rate(rate_tier text DEFAULT 'standard') RETURNS numeric LANGUAGE plpgsql SECURITY DEFINER SET search_path = public, pg_temp AS $$ DECLARE billing_rate numeric; BEGIN SELECT CASE WHEN rate_tier = 'standard' THEN standard_rate WHEN rate_tier = 'overtime' THEN overtime_rate WHEN rate_tier = 'emergency' THEN emergency_rate ELSE standard_rate END INTO billing_rate FROM public.labor_rate_profile WHERE is_active = true ORDER BY effective_date DESC LIMIT 1; RETURN COALESCE(billing_rate, 75.00); END; $$;
CREATE OR REPLACE FUNCTION public.calculate_time_log_amounts() RETURNS trigger LANGUAGE plpgsql SECURITY DEFINER SET search_path = public, pg_temp AS $$ DECLARE hours_worked numeric; user_labor_cost numeric; rate_tier text; global_rate numeric; BEGIN IF NEW.clock_out IS NOT NULL AND NEW.clock_in IS NOT NULL THEN hours_worked := EXTRACT(EPOCH FROM (NEW.clock_out - NEW.clock_in)) / 3600.0; SELECT labor_cost_per_hour INTO user_labor_cost FROM public.profiles WHERE id = NEW.user_id; NEW.labor_cost := hours_worked * COALESCE(user_labor_cost, 25.00); rate_tier := public.get_current_labor_rate_tier(NEW.clock_in::date); NEW.labor_rate_tier := rate_tier; global_rate := public.get_global_billing_rate(rate_tier); NEW.billing_rate := global_rate; NEW.labor_charge := hours_worked * global_rate; NEW.labor_margin := NEW.labor_charge - NEW.labor_cost; END IF; RETURN NEW; END; $$;
CREATE OR REPLACE FUNCTION public.update_updated_at_column() RETURNS trigger LANGUAGE plpgsql SECURITY DEFINER SET search_path = public, pg_temp AS $$ BEGIN NEW.updated_at = now(); RETURN NEW; END; $$;
CREATE FUNCTION public.get_current_user_role() RETURNS text LANGUAGE plpgsql SECURITY DEFINER SET search_path = public, pg_temp AS $$ DECLARE user_role text; BEGIN SELECT role INTO user_role FROM public.profiles WHERE id = auth.uid(); RETURN COALESCE(user_role, 'technician'); END; $$;
